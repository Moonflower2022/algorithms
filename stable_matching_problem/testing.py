from collections.abc import Iterable
from implementation import StableMatcher

def replace(array, repalcement_map):
    new_array = []
    for element in array:
        if isinstance(element, Iterable) and not isinstance(element, str):
            new_array.append(replace(element, repalcement_map))
        else:
            new_array.append(repalcement_map[element])

    return new_array


def test_2():
    a_preferences_list = [[0, 1], [1, 0]]
    b_preferences_list = [[0, 1], [1, 0]]

    matcher = StableMatcher(a_preferences_list, b_preferences_list)

    print(matcher.match())


def test_3():

    replacement_map = {
        "A": 0,
        "B": 1,
        "C": 2
    }

    a_preferences_list = replace([["B", "A", "C"], ["B", "C", "A"], ["A", "B", "C"]], replacement_map)
    b_preferences_list = replace([["A", "B", "C"], ["A", "C", "B"], ["B", "C", "A"]], replacement_map)

    print(a_preferences_list, b_preferences_list)

    matcher = StableMatcher(a_preferences_list, b_preferences_list)

    matching = matcher.match()

    print(matching)

    inverse_replacement_map = {value: key for key, value in replacement_map.items()}

    print(replace(matching, inverse_replacement_map))

def test_4(): # generated by ChatGPT-4o
    # Mapping individuals to indices for Group A and Group B
    replacement_map_a = {
        "m1": 0,
        "m2": 1,
        "m3": 2,
        "m4": 3
    }

    replacement_map_b = {
        "w1": 0,
        "w2": 1,
        "w3": 2,
        "w4": 3
    }

    # Preferences of Group A (Men) for Group B (Women)
    a_preferences_list = replace([
        ["w4", "w1", "w2", "w3"],  # m1's preferences
        ["w2", "w3", "w1", "w4"],  # m2's preferences
        ["w2", "w4", "w3", "w1"],  # m3's preferences
        ["w3", "w1", "w4", "w2"]   # m4's preferences
    ], replacement_map_b)

    # Preferences of Group B (Women) for Group A (Men)
    b_preferences_list = replace([
        ["m4", "m1", "m3", "m2"],  # w1's preferences
        ["m1", "m3", "m2", "m4"],  # w2's preferences
        ["m1", "m2", "m3", "m4"],  # w3's preferences
        ["m4", "m1", "m2", "m3"]   # w4's preferences
    ], replacement_map_a)

    print(a_preferences_list, b_preferences_list)

    matcher = StableMatcher(a_preferences_list, b_preferences_list)

    matching = matcher.match()

    print(matching)

    # Inverse map to convert back to original names
    inverse_replacement_map_a = {value: key for key, value in replacement_map_a.items()}
    inverse_replacement_map_b = {value: key for key, value in replacement_map_b.items()}

    formatted_matching = [
        (inverse_replacement_map_a[group_a_index], inverse_replacement_map_b[group_b_index])
        for group_a_index, group_b_index in matching
    ]

    print(formatted_matching)


if __name__ == "__main__":
    test_4()
